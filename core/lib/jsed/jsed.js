class JSEDObject
{
	constructor(fileName, fileExtension, data)
	{
		this.fileName = fileName;
		this.fileExtension = fileExtension;
		this.data = data;
	}
}

class JSEDResult
{
	constructor(src)
	{
		this.src = src;
		this.jsedObjects = {}
	}

	addJsedObject(jsedObject)
	{
		this.jsedObjects[jsedObject.fileName] = jsedObject;
	}

	get(fileName)
	{
		return this.jsedObjects[fileName];
	}

	getAny()
	{
		for (var jsedObjectKey in this.jsedObjects)
			return this.jsedObjects[jsedObjectKey];
	}
}

class JSED
{
	/* JSED = JavaScript Encoded Data
	   JSED is a file format that fixes the CORS problem for a locally executed 
	   HTML file. AJAX requesting another local asset, such as a JSON file, will
	   fail due to browser security concerns. By encoding the data in the JSED
	   format these problems are solved and the assets can be loaded.
	*/

	static parse(src, onCompleteCallback, async = true, reload = false)
	{
		// This method is called when a JSED file should be parsed and when 
		// the parsing has been completed, a completion callback is called.

		/* The arguments:
				src =					The source of the .jsed file that is to be parsed.

				onCompleteCallback =	The callback that is called, with the parsed data as an
										argument, when the parsing has completed.

				async =					A boolean stating whether the src file should be loaded 
										asynchronously or not.

				reload =				A boolean stating whether previously parsed results can 
										be used or not.
		*/

		if (reload)
		{
			// Clear the state of a src if a reload is requested.

			JSED.clearState(src);
		}

		if (src in JSED.parsedData)
		{
			// Call the completion callbacks if the asset has already
			// been parsed and if it should not be reloaded.

			onCompleteCallback(JSED.parsedData[src]);
		}
		else if (src in JSED.onCompleteCallbacks)
		{
			// If the parsing has already been started, but not finished,
			// then just add the new callback to the callbacks without
			// starting a new parsing process.

			JSED.addOnCompleteCallback(src, onCompleteCallback);
		}
		else
		{
			// Assign the completion callback
			JSED.addOnCompleteCallback(src, onCompleteCallback);

			// Create a script element for the .jsed file. 
			var scriptElement = document.createElement('script');

			if (async)
			{
				scriptElement.async = '';
			}

			scriptElement.src = src;

			// Append the script element to the head section of the current
			// HTML page. This will execute the script tag, which in turn 
			// will parse the supplied data and finally call on the completion
			// callback.
			document.head.appendChild(scriptElement);
		}

	}
	
	static clearState(src)
	{
		// Clear the state for a specific src. This might be handy if 
		// one wishes to free memory.

		if (src in JSED.parsedData)
		{
			delete JSED.parsedData[src];
		}

		if (src in JSED.onCompleteCallbacks)
		{
			delete JSED.onCompleteCallbacks[src];
		}
	}

	static callOnCompleteCallbacks(src)
	{
		// Call all callbacks that corresponds to src.

		if (src in JSED.onCompleteCallbacks)
		{
			var callbacks = JSED.onCompleteCallbacks[src];

			for (var i = 0; i < callbacks.length; i++)
			{
				callbacks[i](JSED.parsedData[src]);
			}
		}
	}
	static addOnCompleteCallback(src, onCompleteCallback)
	{
		// Add a onCompleteCallback that corresponds to src.

		if (!(src in JSED.onCompleteCallbacks))
		{
			JSED.onCompleteCallbacks[src] = [];
		}

		JSED.onCompleteCallbacks[src].push(onCompleteCallback);

	}

	static async execute(scriptElement, conversionFunctionName, encodingsString, fileNamesString, fileExtensionsString, encodedData)
	{
		// This method is called when the script generated by JSED.parse() hase been loaded and
		// actually parses the data. After the data has been converted a completion callback is 
		// called.

		/* The arguments:
				scriptElement =				The script HTML tag that calls this method.

				conversionFunctionName =	The name of the conversion function that will be
											called when the data has been completely decoded.
											The function will return a JavaScript representation
											of the encoded data.

				encodingsString =			A string of encoding methods, delimeted by the null bytes 
											character ("\0"), that have been used to encode the data.
											The order of the methods is such that the data should be
											decoded from left to right.

				fileNamesString =			A string of filenames, delimeted by the null bytes character 
											("\0"), that are contained within the JSED file. The returned
											object parsed by JSED.parse() is a dictionary of all filenames
											and their JavaScript representations and file extensions. The 
											filenames act as keys.

				fileExtensionsString =		A string of file extensions, delimeted by the null bytes
											character ("\0"), that are contained within the JSED file.
											These correspond to the filenames at the same index position
											in fileNamesString. These values are used to parse the data
											to JavaScript representations. For example, JSONs will be 
											parsed to objects, while .txts will be parsed to plain
											strings.

				encodedData =				The JSED encoded data as a string. This is the data that will
											be parsed.

		*/

		// Get the source of the currently executing script.
		var src = scriptElement.getAttribute('src');

		// Split the input parameters which represents lists.
		var encodings = encodingsString.split(JSED.delimeter).filter(String);
		var fileNames = fileNamesString.split(JSED.delimeter).filter(String);
		var fileExtensions = fileExtensionsString.split(JSED.delimeter).filter(String);

		// Write the input parameters as attributes to the originating script. 
		scriptElement.setAttribute(JSED.conversionFunctionAttributeName, conversionFunctionName)
		scriptElement.setAttribute(JSED.encodingsAttributeName, encodingsString);
		scriptElement.setAttribute(JSED.fileNamesAttributeName, fileNamesString);
		scriptElement.setAttribute(JSED.fileExtensionsAttributeName, fileExtensionsString);

		// Loop through the encodings and decode accordingly.
		for (var i = 0; i < encodings.length; i++)
		{
			var encoding = encodings[i];
			encodedData = await JSED.decode(encoding, encodedData);
		}

		// The encoded data has now been decoded.
		var decodedData = encodedData;

		// Convert the decodedData data.
		var convertedObject = await JSED.convert(conversionFunctionName, decodedData, fileNames, fileExtensions, src);

		// Store the data and call all the corresponding onComplete callbacks.
		JSED.parsedData[src] = convertedObject;
		JSED.callOnCompleteCallbacks(src);
	}

	static async decode(encoding, encodedData)
	{
		// This function decodes data encoded with some encoding. The input
		// data is a string and so is the returned data. Throws an error
		// if a decoding method for the inputted encoding has not been 
		// implemented.

		/* The arguments:
				encoding =	The encoding with which the data has been encoded.
							The value is case-insensitive.
			
				data =		The data to be decoded. The type is string.
		*/

		encoding = encoding.toLowerCase();
		if (encoding in JSED.decodingFunctions)
		{
			return await JSED.decodingFunctions[encoding](encodedData);
		}

		throw new Error("Error! Decoding for the encoding: '" + encoding + "' has not been implemented.");
	}
	static async parseFile(fileFormat, fileData)
	{
		// This function parses file data to a JavaScript
		// representation. For example, JSONs will be parsed to 
		// objects, while .txts will be parsed to plain strings.
		// Throws an error if a parsing function has not been 
		// implemented for the requested file format. 

		/* The arguments:
				fileFormat =	The file format of the data that is to be parsed.

				fileData =		The data that is to be parsed as a string.
		*/

		fileFormat = fileFormat.toLowerCase();
		if (fileFormat in JSED.fileFormatParsingFunctions)
		{
			return await JSED.fileFormatParsingFunctions[fileFormat](fileData);
		}

		throw new Error("Error! Parsing function for the file format: '" + fileFormat + "' has not been implemented.");
	}
	static async convert(conversionFunctionName, decodedData, fileNames, fileExtensions, src)
	{
		// This function converts the decoded data to a JavaScript
		// representation. Throws an error if a conversion function 
		// for the requested conversion function name has not been 
		// implemented.

		/* The arguments:
				conversionFunctionName =	The name of the conversion function to be used.
	
				decodedData =				The already decoded data, which will be converted.
		*/

		conversionFunctionName = conversionFunctionName.toLowerCase();
		if (conversionFunctionName in JSED.conversionFunctions)
		{
			return await JSED.conversionFunctions[conversionFunctionName](decodedData, fileNames, fileExtensions, src);
		}

		throw new Error("Error! Conversion function: '" + conversionFunctionName + "' has not been implemented.");
	}

	static setDecodingFunction(encoding, decodeFunction)
	{
		// Set a decoding function for an encoding.
		// The function should take a string as argument
		// and should return a string.

		encoding = encoding.toLowerCase();
		JSED.decodingFunctions[encoding] = decodeFunction;
	}
	static setDecodingFunctionForMany(encodings, decodeFunction)
	{
		for (var i = 0; i < encodings.length; i++)
		{
			JSED.setDecodingFunction(encodings[i], decodeFunction);
		}
	}

	static setFileFormatParsingFunction(fileFormat, parsingFunction)
	{
		// Set a conversion function for a conversion function name.
		// The conversion function takes the following arguments:
		// decodedData (string), fileNames (array of strings), 
		// fileExtensions(array of strings). The conversion function
		// returns a JavaScript object.

		fileFormat = fileFormat.toLowerCase();
		JSED.fileFormatParsingFunctions[fileFormat] = parsingFunction;
	}
	static setFileFormatParsingFunctionForMany(fileFormats, parsingFunction)
	{
		for (var i = 0; i < fileFormats.length; i++)
		{
			JSED.setFileFormatParsingFunction(fileFormats[i], parsingFunction);
		}
	}

	static setConversionFunction(conversionFunctionName, conversionFunction)
	{
		// Set a conversion function for a conversion function name.
		// The function should take an string as argument
		// and should returns a string.

		conversionFunctionName = conversionFunctionName.toLowerCase();
		JSED.conversionFunctions[conversionFunctionName] = conversionFunction;
	}
	static setConversionFunctionForMany(conversionFunctionNames, conversionFunction)
	{
		for (var i = 0; i < conversionFunctionNames.length; i++)
		{
			JSED.setConversionFunction(conversionFunctionNames[i], conversionFunction);
		}
	}

}

// The JSED delimeter is the null byte character ("\0"). This is appropriate, since the
// null byte character can't appear in a file name in either UNIX or WINDOWS systems. This
// means that there should never be any problems, regardless of what files are encoded to 
// the JSED format.
JSED.delimeter = "\0";

// The names of the attributes of the script that will be created and executed when calling
// JSED.parse(). This attributes do not serve any functional purposes, but might be good
// for debugging purposes.
JSED.conversionFunctionAttributeName = 'data-conversion';
JSED.encodingsAttributeName = 'data-encodings';
JSED.fileNamesAttributeName = 'data-file-names';
JSED.fileExtensionsAttributeName = 'data-file-extensions';

// Dictionaries that store the state of parsed JSED files and their corresponding callbacks. 
// By storing the results, we can avoid decoding the same file twice.
JSED.parsedData = {};
JSED.onCompleteCallbacks = {};

// Dictionaries of functions that are used in the JSED parsing process.
JSED.decodingFunctions = {};
JSED.conversionFunctions = {};
JSED.fileFormatParsingFunctions = {};

// Implementations

JSED.setDecodingFunction('base64', async function (encodedData)
{
	return atob(encodedData);
});

JSED.setFileFormatParsingFunction('json', async function (data)
{
	return JSON.parse(data);
});
JSED.setFileFormatParsingFunction('html', async function (data)
{
	var div = document.createElement('div');
	div.innerHTML = data.trim();

	return div.firstChild;
});
JSED.setFileFormatParsingFunction('csv', async function (data)
{
	return Papa.parse(data, { dynamicTyping: true, header: true, skipEmptyLines: true }).data;
});

JSED.setFileFormatParsingFunctionForMany(['txt', 'text'], async function (data)
{
	return data;
});

JSED.setConversionFunction('file', async function (decodedData, fileNames, fileExtensions, src)
{
	// The conversion function "file" implies that only one file exists.
	var fileName = fileNames[0];
	var fileExtension = fileExtensions[0];

	var jsedObject = new JSEDObject(fileName, fileExtension, await JSED.parseFile(fileExtension, decodedData));

	var jsedResult = new JSEDResult(src);
	jsedResult.addJsedObject(jsedObject);

	return jsedResult;
});
JSED.setConversionFunction('zip', async function (decodedData, fileNames, fileExtensions, src)
{
	function zipEntryOnCompleteCallbackGenerator(fileName, fileExtension, jsedResult, zipEntryPromiseResolve)
	{
		return async function (data)
		{
			var jsedObject = new JSEDObject(fileName, fileExtension, await JSED.parseFile(fileExtension, data));

			jsedResult.addJsedObject(jsedObject);

			zipEntryPromiseResolve();
		}
	}

	var bytes = new Uint8Array(decodedData.length);
	for (var i = 0; i < decodedData.length; i++)
		bytes[i] = decodedData.charCodeAt(i);

	var blobData = new Blob([bytes]);

	var promises = []

	var initializationPromiseResolve = null;
	var initializationPromise = new Promise(function (resolve, reject)
	{
		initializationPromiseResolve = resolve;
	});

	promises.push(initializationPromise);

	var jsedResult = new JSEDResult(src);

	zip.createReader(new zip.BlobReader(blobData), function (reader)
	{
		reader.getEntries(function (entries)
		{
			if (entries.length)
			{
				for (var i = 0; i < entries.length; i++)
				{
					var zipEntryPromiseResolve = null;
					var zipEntryPromise = new Promise(function (resolve, reject)
					{
						zipEntryPromiseResolve = resolve;
					});

					promises.push(zipEntryPromise);

					entries[i].getData(new zip.TextWriter(), zipEntryOnCompleteCallbackGenerator(fileNames[i], fileExtensions[i], jsedResult, zipEntryPromiseResolve),
						function (current, total)
						{
							// progress callback
						});
				}

			}

			initializationPromiseResolve();

		});
	});

	for (var i = 0; i < promises.length; i++)
	{
		await promises[i];
	}


	return jsedResult;
});

